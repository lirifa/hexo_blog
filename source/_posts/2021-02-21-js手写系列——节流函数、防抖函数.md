---
title: js手写系列——节流函数、防抖函数
date: 2021-02-21 17:36:43
updated: 2021-02-22 15:26:03
tags: [js]
categories: js手写系列
---

节流（throttle）是一种常用的性能优化技术，用于限制函数在特定时间间隔内只能执行一次。当频繁触发某个事件时，节流可以确保函数不会过于频繁地执行，从而提升性能。
防抖（Debounce）是一种常用的性能优化技术，用于限制函数在短时间内被频繁调用。当事件被触发后，会等待一定时间间隔，如果在这段时间内事件没有被再次触发，才会执行函数。如果在这段时间内事件又被触发，则重新开始计时。

<!--more-->

# 节流函数
## 节流的基本概念

节流的核心思想是：**在一定时间间隔内，无论事件触发多少次，函数只会执行一次。**

与防抖(debounce)不同，防抖是在事件停止触发后延迟执行，而节流是保证在固定时间间隔内至少执行一次。

## 应用场景

- 窗口大小调整(resize)事件
- 页面滚动(scroll)事件
- 鼠标移动(mousemove)事件
- 输入框实时搜索(减少请求频率)

## 实现

1. 基础时间戳版节流
- 使用时间戳判断是否达到执行间隔
- 第一次会立即执行
- 停止触发后不会再次执行
```javascript
function throttleBasic(func, delay) {
    let lastTime = 0;
    return function (...args) {
        const currentTime = Date.now();
        if (currentTime - lastTime >= delay) {
            func.apply(this, args);
            lastTime = currentTime;
        }
    };
}
```

2. 定时器版节流
- 使用定时器延迟执行
- 第一次不会立即执行
- 停止触发后会再执行一次
```javascript
function throttleTimer(func, delay) {
    let timeoutId = null;
    return function(...args) {
        if (!timeoutId) {
            timeoutId = setTimeout(() => {
                func.apply(this, args);
                timeoutId = null;
            }, delay);
        }
    };
}
```

3. 完整版节流（结合时间戳和定时器）
- 结合时间戳和定时器
- 可配置是否立即执行（leading）和停止后是否执行（trailing)
- 功能最完整，适用性最广
```javascript
function throttle(func, delay, options = {}) {
    // 函数签名和变量声明
    // func: 需要被节流的原始函数
    // delay: 节流时间间隔（毫秒）
    // options: 配置对象，包含 leading 和 trailing 选项
    // timeoutId: 存储定时器ID，用于取消定时器
    // lastTime: 记录上一次函数执行的时间戳
    // leading: 是否在节流开始时立即执行（默认true）
    // trailing: 是否在节流结束后执行（默认true）
    let timeoutId, lastTime = 0;
    const { leading = true, trailing = true } = options;
    
    // 返回的节流函数
    return function(...args) {
        // 保存原始函数的this上下文和参数
        const currentTime = Date.now();
        
        // 处理leading=false的情况, 如果是第一次调用且leading为false，设置lastTime为当前时间, 这样第一次调用不会立即执行
        if (!lastTime && !leading) lastTime = currentTime;
        
        // 计算距离下一次可以执行函数还剩余多少时间, currentTime - lastTime是距离上次执行经过的时间
        const remainingTime = delay - (currentTime - lastTime);
        
        // 判断是否需要立即执行
        // remainingTime <= 0: 已经超过了节流间隔，可以立即执
        // remainingTime > delay: 处理特殊情况（如系统时间被修改）
        if (remainingTime <= 0 || remainingTime > delay) {
            if (timeoutId) {
                // 清除可能存在的定时器
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            // 立即执行原始函数
            func.apply(this, args);
            // 更新最后执行时间
            lastTime = currentTime;
        } else if (!timeoutId && trailing) {
            //  设置延迟执行
            // !timeoutId: 确保不会重复设置定时器
            // trailing: 配置允许在节流结束后执行
            timeoutId = setTimeout(() => {
                func.apply(this, args);
                lastTime = Date.now();
                timeoutId = null;
            }, remainingTime);
        }
    };
}
```

## 使用建议
- 对于需要立即响应的场景（如按钮点击），使用基础时间戳版
- 对于需要保证最后一次执行的场景，使用定时器版
- 大多数情况下，推荐使用完整版，因为它提供了最灵活的控制选项

# 防抖函数
## 防抖的核心概念
防抖的核心思想是：在事件被触发后，等待一定时间间隔，如果在这段时间内事件没有被再次触发，才会执行函数。如果在这段时间内事件再次被触发，则重新计时。

## 防抖的工作原理
1. 事件触发时，设置一个定时器
2. 如果在定时器结束前事件再次触发，则清除之前的定时器并重新设置
3. 只有当事件停止触发一段时间后，函数才会执行

## 防抖的应用场景
- 搜索框输入建议
- 窗口大小调整(resize)事件
- 表单验证
- 按钮点击防重复提交
- 自动保存功能

## 实现
1. 基础防抖函数
```javascript
function debounceBasic(func, delay) {
    let timeoutId;
    
    return function(...args) {
        // 清除之前的定时器
        clearTimeout(timeoutId);
        
        // 设置新的定时器
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}
```
2. 立即执行版防抖函数
```javascript
function debounceImmediate(func, delay, immediate = false) {
    let timeoutId;
    
    return function(...args) {
        const context = this;
        const callNow = immediate && !timeoutId;
        
        clearTimeout(timeoutId);
        
        timeoutId = setTimeout(() => {
            timeoutId = null;
            if (!immediate) {
                func.apply(context, args);
            }
        }, delay);
        
        if (callNow) {
            func.apply(context, args);
        }
    };
}
```
3. 增强版防抖函数
```javascript
function debounceEnhanced(func, delay, options = {}) {
    let timeoutId;
    let lastExecTime = 0;
    let leading = options.leading || false;
    let trailing = options.trailing !== false; // 默认true
    
    return function(...args) {
        const context = this;
        const currentTime = Date.now();
        
        // 立即执行逻辑
        if (leading && !timeoutId) {
            func.apply(context, args);
            lastExecTime = currentTime;
        }
        
        clearTimeout(timeoutId);
        
        // 延迟执行逻辑
        if (trailing) {
            timeoutId = setTimeout(() => {
                func.apply(context, args);
                lastExecTime = Date.now();
                timeoutId = null;
            }, delay);
        }
    };
}

```


## 防抖与节流的区别
| 特性     |防抖(Debounce)     | 	节流(Throttle)  |
|---------|-----------------|-------------------|
| 执行时机  | 在事件停止触发后执行      | 在固定时间间隔内执行  |
| 执行次数 | 只执行最后一次         | 至少执行一次  |
| 适用场景 | 搜索框输入、窗口调整      | 页面滚动、鼠标移动  |


# 涉及知识点
- [闭包](https://lirifa.github.io/js%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html)